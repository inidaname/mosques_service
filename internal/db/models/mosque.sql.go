// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: mosque.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMosque = `-- name: CreateMosque :one
INSERT INTO mosques (id, name, address, eid_time, jummah_time, lat, lng, created_at)
VALUES (uuid_generate_v4(), $1, $2, $3, $4, $5, $6, NOW())
RETURNING id, name, address, eid_time, jummah_time, lat, lng, created_at, updated_at
`

type CreateMosqueParams struct {
	Name       string           `json:"name"`
	Address    string           `json:"address"`
	EidTime    pgtype.Timestamp `json:"eid_time"`
	JummahTime pgtype.Timestamp `json:"jummah_time"`
	Lat        pgtype.Numeric   `json:"lat"`
	Lng        pgtype.Numeric   `json:"lng"`
}

func (q *Queries) CreateMosque(ctx context.Context, arg CreateMosqueParams) (Mosque, error) {
	row := q.db.QueryRow(ctx, createMosque,
		arg.Name,
		arg.Address,
		arg.EidTime,
		arg.JummahTime,
		arg.Lat,
		arg.Lng,
	)
	var i Mosque
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.EidTime,
		&i.JummahTime,
		&i.Lat,
		&i.Lng,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllMosque = `-- name: GetAllMosque :many
SELECT id, name, address, eid_time, jummah_time, lat, lng, created_at, updated_at FROM mosques
`

func (q *Queries) GetAllMosque(ctx context.Context) ([]Mosque, error) {
	rows, err := q.db.Query(ctx, getAllMosque)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Mosque{}
	for rows.Next() {
		var i Mosque
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.EidTime,
			&i.JummahTime,
			&i.Lat,
			&i.Lng,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUMosqueByName = `-- name: GetUMosqueByName :one
SELECT id, name, address, eid_time, jummah_time, lat, lng, created_at, updated_at FROM mosques
WHERE name = $1 LIMIT 1
`

func (q *Queries) GetUMosqueByName(ctx context.Context, name string) (Mosque, error) {
	row := q.db.QueryRow(ctx, getUMosqueByName, name)
	var i Mosque
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.EidTime,
		&i.JummahTime,
		&i.Lat,
		&i.Lng,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMosque = `-- name: UpdateMosque :one
UPDATE mosques
SET
  name = coalesce($1, name),
  address = coalesce($2, address),
  eid_time = coalesce($3, eid_time),
  jummah_time = coalesce($4, jummah_time),
  lat = coalesce($5, lat),
  lng = coalesce($6, lng)
WHERE id = $7
RETURNING id, name, address, eid_time, jummah_time, lat, lng, created_at, updated_at
`

type UpdateMosqueParams struct {
	Name       pgtype.Text      `json:"name"`
	Address    pgtype.Text      `json:"address"`
	EidTime    pgtype.Timestamp `json:"eid_time"`
	JummahTime pgtype.Timestamp `json:"jummah_time"`
	Lat        pgtype.Numeric   `json:"lat"`
	Lng        pgtype.Numeric   `json:"lng"`
	ID         pgtype.UUID      `json:"id"`
}

func (q *Queries) UpdateMosque(ctx context.Context, arg UpdateMosqueParams) (Mosque, error) {
	row := q.db.QueryRow(ctx, updateMosque,
		arg.Name,
		arg.Address,
		arg.EidTime,
		arg.JummahTime,
		arg.Lat,
		arg.Lng,
		arg.ID,
	)
	var i Mosque
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.EidTime,
		&i.JummahTime,
		&i.Lat,
		&i.Lng,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
